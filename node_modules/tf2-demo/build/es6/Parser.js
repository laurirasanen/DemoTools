import { MessageType } from './Data/Message';
import { ParserState } from './Data/ParserState';
import { parseHeader } from './Parser/Header';
import { ConsoleCmdHandler } from './Parser/Message/ConsoleCmd';
import { DataTableHandler } from './Parser/Message/DataTable';
import { PacketMessageHandler } from './Parser/Message/Packet';
import { StopHandler } from './Parser/Message/Stop';
import { StringTableHandler } from './Parser/Message/StringTable';
import { SyncTickHandler } from './Parser/Message/SyncTick';
import { UserCmdHandler } from './Parser/Message/UserCmd';
export const messageHandlers = new Map([
    [MessageType.Sigon, PacketMessageHandler],
    [MessageType.Packet, PacketMessageHandler],
    [MessageType.ConsoleCmd, ConsoleCmdHandler],
    [MessageType.UserCmd, UserCmdHandler],
    [MessageType.DataTables, DataTableHandler],
    [MessageType.StringTables, StringTableHandler],
    [MessageType.SyncTick, SyncTickHandler],
    [MessageType.Stop, StopHandler]
]);
export class Parser {
    constructor(stream, skipPackets = []) {
        this.header = null;
        this.lastMessage = -1;
        this.stream = stream;
        this.parserState = new ParserState();
        this.parserState.skippedPackets = skipPackets;
    }
    getHeader() {
        if (!this.header) {
            this.header = parseHeader(this.stream);
        }
        return this.header;
    }
    *getPackets() {
        // ensure that we are past the header
        this.getHeader();
        for (const message of this.iterateMessages()) {
            yield* this.handleMessage(message);
        }
    }
    *getMessages() {
        // ensure that we are past the header
        this.getHeader();
        for (const message of this.iterateMessages()) {
            for (const _ of this.handleMessage(message)) {
                // noop, loop needed to "drain" iterator
            }
            yield message;
        }
    }
    *iterateMessages() {
        while (true) {
            const message = this.readMessage(this.stream, this.parserState);
            yield message;
            if (message.type === MessageType.Stop) {
                return;
            }
        }
    }
    *handleMessage(message) {
        this.parserState.handleMessage(message);
        if (message.type === MessageType.Packet) {
            for (const packet of message.packets) {
                this.parserState.handlePacket(packet);
                yield packet;
            }
        }
    }
    readMessage(stream, state) {
        if (stream.bitsLeft < 8) {
            throw new Error('Stream ended without stop packet');
        }
        const type = stream.readUint8();
        if (type === 0) {
            return {
                type: MessageType.Stop,
                rawData: stream.readBitStream(0)
            };
        }
        const handler = messageHandlers.get(type);
        if (!handler) {
            throw new Error(`No handler for message of type ${MessageType[type]}(${type}),
			last message: ${MessageType[this.lastMessage]}(${this.lastMessage})`);
        }
        this.lastMessage = type;
        return handler.parseMessage(this.stream, state);
    }
}
//# sourceMappingURL=Parser.js.map