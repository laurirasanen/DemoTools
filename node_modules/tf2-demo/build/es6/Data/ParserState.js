import { handleGameEventList } from '../PacketHandler/GameEventList';
import { handlePacketEntitiesForState } from '../PacketHandler/PacketEntities';
import { handleStringTable, handleStringTables, handleStringTableUpdate, handleTable } from '../PacketHandler/StringTable';
import { MessageType } from './Message';
export class ParserState {
    constructor() {
        this.version = 0;
        this.staticBaseLines = new Map();
        this.staticBaselineCache = new Map();
        this.eventDefinitions = new Map();
        this.eventDefinitionTypes = new Map();
        this.entityClasses = new Map();
        this.sendTables = new Map();
        this.stringTables = [];
        this.serverClasses = [];
        this.instanceBaselines = [new Map(), new Map()];
        this.skippedPackets = [];
        this.userInfo = new Map();
        this.tick = 0;
    }
    handlePacket(packet) {
        switch (packet.packetType) {
            case 'netTick':
                this.tick = packet.tick;
                break;
            case 'serverInfo':
                this.version = packet.version;
                break;
            case 'stringTable':
                handleStringTables(packet, this);
                break;
            case 'createStringTable':
                handleStringTable(packet, this);
                break;
            case 'updateStringTable':
                handleStringTableUpdate(packet, this);
                break;
            case 'gameEventList':
                handleGameEventList(packet, this);
                break;
            case 'packetEntities':
                handlePacketEntitiesForState(packet, this);
                break;
        }
    }
    handleMessage(message) {
        switch (message.type) {
            case MessageType.DataTables:
                this.handleDataTableMessage(message);
                break;
            case MessageType.StringTables:
                this.handleStringTableMessage(message);
                break;
        }
    }
    getStringTable(name) {
        const table = this.stringTables.find((stringTable) => stringTable.name === name);
        if (!table) {
            return null;
        }
        return table;
    }
    getUserEntityInfo(userId) {
        const info = this.userInfo.get(userId);
        if (info) {
            return info;
        }
        return {
            name: '',
            userId,
            steamId: '',
            entityId: 0
        };
    }
    handleDataTableMessage(message) {
        for (const table of message.tables) {
            this.sendTables.set(table.name, table);
        }
        this.serverClasses = message.serverClasses;
    }
    handleStringTableMessage(message) {
        for (const table of message.tables) {
            handleTable(table, this);
        }
    }
}
export function getClassBits(state) {
    return Math.ceil(Math.log(state.serverClasses.length) * Math.LOG2E);
}
export function getSendTable(state, dataTable) {
    const sendTable = state.sendTables.get(dataTable);
    if (!sendTable) {
        throw new Error(`Unknown sendTable ${dataTable}`);
    }
    return sendTable;
}
export function createParserState() {
    return new ParserState();
}
//# sourceMappingURL=ParserState.js.map